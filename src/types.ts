import { EmbeddingModelV1, LanguageModelV1, ProviderV1 } from "@ai-sdk/provider"
import { FetchFunction } from "@ai-sdk/provider-utils"

export type UndrstndChatModelId =
  | "distil-whisper-large-v3-en"
  | "gemma2-9b-it"
  | "gemma-7b-it"
  | "llama3-groq-70b-8192-tool-use-preview"
  | "llama3-groq-8b-8192-tool-use-preview"
  | "llama-3.1-405b"
  | "llama-3.1-70b-versatile"
  | "llama-3.1-8b-instant"
  | "llama-guard-3-8b"
  | "llama3-70b-8192"
  | "llama3-8b-8192"
  | "mixtral-8x7b-32768"
  | "whisper-large-v3"
  | (string & {})

interface ClientChatSettings {
  /**
  Modify the likelihood of specified tokens appearing in the completion.
  
  Accepts a JSON object that maps tokens (specified by their token ID in
  the GPT tokenizer) to an associated bias value from -100 to 100. You
  can use this tokenizer tool to convert text to token IDs. Mathematically,
  the bias is added to the logits generated by the model prior to sampling.
  The exact effect will vary per model, but values between -1 and 1 should
  decrease or increase likelihood of selection; values like -100 or 100
  should result in a ban or exclusive selection of the relevant token.
  
  As an example, you can pass {"50256": -100} to prevent the <|endoftext|>
  token from being generated.
  */
  logitBias?: Record<number, number>
  /**
  Return the log probabilities of the tokens. Including logprobs will increase
  the response size and can slow down response times. However, it can
  be useful to better understand how the model is behaving.
  
  Setting to true will return the log probabilities of the tokens that
  were generated.
  
  Setting to a number will return the log probabilities of the top n
  tokens that were generated.
  */
  logprobs?: boolean | number
  /**
  Whether to enable parallel function calling during tool use. Default to true.
     */
  parallelToolCalls?: boolean
  /**
  Whether to use structured outputs. Defaults to false.
  
  When enabled, tool calls and object generation will be strict and follow the provided schema.
   */
  structuredOutputs?: boolean
  /**
  Whether to use legacy function calling. Defaults to false.
  
  Required by some open source inference engines which do not support the `tools` API. May also
  provide a workaround for `parallelToolCalls` resulting in the provider buffering tool calls,
  which causes `streamObject` to be non-streaming.
  
  Prefer setting `parallelToolCalls: false` over this option.
  
  @deprecated this API is supported but deprecated by Client.
     */
  useLegacyFunctionCalling?: boolean
  /**
  A unique identifier representing your end-user, which can help Client to
  monitor and detect abuse. Learn more.
  */
  user?: string
}

type ClientChatConfig = {
  provider: string
  compatibility: "strict" | "compatible"
  headers: () => Record<string, string | undefined>
  url: (options: { modelId: string; path: string }) => string
  fetch?: FetchFunction
}
declare class ClientChatLanguageModel implements LanguageModelV1 {
  readonly specificationVersion = "v1"
  readonly modelId: UndrstndChatModelId
  readonly settings: ClientChatSettings
  private readonly config
  constructor(
    modelId: UndrstndChatModelId,
    settings: ClientChatSettings,
    config: ClientChatConfig
  )
  get supportsStructuredOutputs(): boolean
  get defaultObjectGenerationMode(): "tool" | "json"
  get provider(): string
  private getArgs
  doGenerate(
    options: Parameters<LanguageModelV1["doGenerate"]>[0]
  ): Promise<Awaited<ReturnType<LanguageModelV1["doGenerate"]>>>
  doStream(
    options: Parameters<LanguageModelV1["doStream"]>[0]
  ): Promise<Awaited<ReturnType<LanguageModelV1["doStream"]>>>
}

type ClientCompletionModelId = "gpt-3.5-turbo-instruct" | (string & {})
interface ClientCompletionSettings {
  /**
  Echo back the prompt in addition to the completion.
     */
  echo?: boolean
  /**
  Modify the likelihood of specified tokens appearing in the completion.
  
  Accepts a JSON object that maps tokens (specified by their token ID in
  the GPT tokenizer) to an associated bias value from -100 to 100. You
  can use this tokenizer tool to convert text to token IDs. Mathematically,
  the bias is added to the logits generated by the model prior to sampling.
  The exact effect will vary per model, but values between -1 and 1 should
  decrease or increase likelihood of selection; values like -100 or 100
  should result in a ban or exclusive selection of the relevant token.
  
  As an example, you can pass {"50256": -100} to prevent the <|endoftext|>
  token from being generated.
     */
  logitBias?: Record<number, number>
  /**
  Return the log probabilities of the tokens. Including logprobs will increase
  the response size and can slow down response times. However, it can
  be useful to better understand how the model is behaving.
  
  Setting to true will return the log probabilities of the tokens that
  were generated.
  
  Setting to a number will return the log probabilities of the top n
  tokens that were generated.
     */
  logprobs?: boolean | number
  /**
  The suffix that comes after a completion of inserted text.
     */
  suffix?: string
  /**
  A unique identifier representing your end-user, which can help Client to
  monitor and detect abuse. Learn more.
     */
  user?: string
}

type ClientCompletionConfig = {
  provider: string
  compatibility: "strict" | "compatible"
  headers: () => Record<string, string | undefined>
  url: (options: { modelId: string; path: string }) => string
  fetch?: FetchFunction
}
declare class ClientCompletionLanguageModel implements LanguageModelV1 {
  readonly specificationVersion = "v1"
  readonly defaultObjectGenerationMode: undefined
  readonly modelId: ClientCompletionModelId
  readonly settings: ClientCompletionSettings
  private readonly config
  constructor(
    modelId: ClientCompletionModelId,
    settings: ClientCompletionSettings,
    config: ClientCompletionConfig
  )
  get provider(): string
  private getArgs
  doGenerate(
    options: Parameters<LanguageModelV1["doGenerate"]>[0]
  ): Promise<Awaited<ReturnType<LanguageModelV1["doGenerate"]>>>
  doStream(
    options: Parameters<LanguageModelV1["doStream"]>[0]
  ): Promise<Awaited<ReturnType<LanguageModelV1["doStream"]>>>
}

type ClientEmbeddingModelId =
  | "text-embedding-3-small"
  | "text-embedding-3-large"
  | "text-embedding-ada-002"
  | (string & {})
interface ClientEmbeddingSettings {
  /**
  Override the maximum number of embeddings per call.
     */
  maxEmbeddingsPerCall?: number
  /**
  Override the parallelism of embedding calls.
      */
  supportsParallelCalls?: boolean
  /**
  The number of dimensions the resulting output embeddings should have.
  Only supported in text-embedding-3 and later models.
     */
  dimensions?: number
  /**
  A unique identifier representing your end-user, which can help Client to
  monitor and detect abuse. Learn more.
  */
  user?: string
}

interface ClientProvider extends ProviderV1 {
  (
    modelId: "gpt-3.5-turbo-instruct",
    settings?: ClientCompletionSettings
  ): ClientCompletionLanguageModel
  (modelId: UndrstndChatModelId, settings?: ClientChatSettings): LanguageModelV1
  /**
  Creates an Client model for text generation.
     */
  languageModel(
    modelId: "gpt-3.5-turbo-instruct",
    settings?: ClientCompletionSettings
  ): ClientCompletionLanguageModel
  languageModel(
    modelId: UndrstndChatModelId,
    settings?: ClientChatSettings
  ): LanguageModelV1
  /**
  Creates an Client chat model for text generation.
     */
  chat(
    modelId: UndrstndChatModelId,
    settings?: ClientChatSettings
  ): LanguageModelV1
  /**
  Creates an Client completion model for text generation.
     */
  completion(
    modelId: ClientCompletionModelId,
    settings?: ClientCompletionSettings
  ): LanguageModelV1
  /**
  Creates a model for text embeddings.
     */
  embedding(
    modelId: ClientEmbeddingModelId,
    settings?: ClientEmbeddingSettings
  ): EmbeddingModelV1<string>
  /**
  Creates a model for text embeddings.
  
  @deprecated Use `textEmbeddingModel` instead.
     */
  textEmbedding(
    modelId: ClientEmbeddingModelId,
    settings?: ClientEmbeddingSettings
  ): EmbeddingModelV1<string>
  /**
  Creates a model for text embeddings.
     */
  textEmbeddingModel(
    modelId: ClientEmbeddingModelId,
    settings?: ClientEmbeddingSettings
  ): EmbeddingModelV1<string>
}
interface ClientProviderSettings {
  /**
  Base URL for the OpenAI API calls.
       */
  baseURL?: string
  /**
  @deprecated Use `baseURL` instead.
       */
  baseUrl?: string
  /**
  API key for authenticating requests.
       */
  apiKey?: string
  /**
  Client Organization.
       */
  organization?: string
  /**
  Client project.
       */
  project?: string
  /**
  Custom headers to include in the requests.
       */
  headers?: Record<string, string>
  /**
  Client compatibility mode. Should be set to `strict` when using the Client API,
  and `compatible` when using 3rd party providers. In `compatible` mode, newer
  information such as streamOptions are not being sent. Defaults to 'compatible'.
     */
  compatibility?: "strict" | "compatible"
  /**
  Custom fetch implementation. You can use it as a middleware to intercept requests,
  or to provide a custom fetch implementation for e.g. testing.
      */
  fetch?: FetchFunction
}
/**
Create an Client provider instance.
 */
declare function createClient(options?: ClientProviderSettings): ClientProvider
/**
Default Client provider instance. It uses 'strict' compatibility mode.
 */
declare const client: ClientProvider

/**
@deprecated Use `createClient` instead.
 */
declare class Client {
  /**
  Use a different URL prefix for API calls, e.g. to use proxy servers.
  The default prefix is `https://api.Client.com/v1`.
     */
  readonly baseURL: string
  /**
  API key that is being send using the `Authorization` header.
  It defaults to the `Client_API_KEY` environment variable.
   */
  readonly apiKey?: string
  /**
  Client Organization.
     */
  readonly organization?: string
  /**
  Client project.
     */
  readonly project?: string
  /**
  Custom headers to include in the requests.
     */
  readonly headers?: Record<string, string>
  /**
   * Creates a new Client provider instance.
   */
  constructor(options?: ClientProviderSettings)
  private get baseConfig()
  chat(
    modelId: UndrstndChatModelId,
    settings?: ClientChatSettings
  ): ClientChatLanguageModel
  completion(
    modelId: ClientCompletionModelId,
    settings?: ClientCompletionSettings
  ): ClientCompletionLanguageModel
}

export {
  Client,
  type ClientProvider,
  type ClientProviderSettings,
  createClient,
  client,
  EmbeddingModelV1,
  LanguageModelV1,
  ProviderV1,
}
